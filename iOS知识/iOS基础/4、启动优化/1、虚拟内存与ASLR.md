# 虚拟内存与ASLR

# 一、虚拟内存

在早期的操作系统中没有虚拟内存的概念，叫做物理地址。大概如下：

![img](https:////upload-images.jianshu.io/upload_images/25092736-779cdbd04d5e9645.png)

image.png


 这个时候会将整个应用程序加载到内存，当内存不够用的时候需要关闭应用程序才能打开新的应用程序。
 随着软件的发展速度远快于硬件，就存在一个问题 **内存不够用**。还有一个问题是如果用物理内存还有 **安全问题**（可以跨进程访问别的应用程序数据）。



> 当然我们现在都是虚拟内存，那么怎么验证呢？
>  很简单，我们用`Xcode`跑两个工程。在一个工程中找到一个内存地址，在另外一个工程中修改，然后再回到第一个工程看对应内存地址数据有没有变化就能验证了。

这个时候出现了内存映射表（**页表**，`iOS`中地址空间`4G`，实际不会让你用完`4G`）：

![img](https:////upload-images.jianshu.io/upload_images/25092736-0392c7914c3f8df0.png)

image.png


 内存映射表将应用程序和物理内存完全阻隔开，应用程序访问的虚拟内存相同，但是映射到物理内存是不同的地址。



之前的物理内存访问存在两个问题：

1. 安全问题：能访问别人的进程。
2. 内存不够用的问题。

通过页表可以解决安全问题，那么内存不够用是怎么解决的呢？
 早期物理内存是将整个应用程序全部加载到内存，但是用户并不会用到软件的全部功能，很大一部分数据是没有用到的。

如果内存映射表以字节为单位那么表会非常大。这个时候就出现了**内存分页管理**（`iOS一页16kb`）。

![img](https:////upload-images.jianshu.io/upload_images/25092736-01839e4c4f463f11.png)

image.png


 应用程序读取第一页的数据，虚拟页表发现物理内存中没有数据则去加载数据（这个时候触发中断`pagefault`）。如果已经加载则通过地址翻译（`MMU`）去找物理内存。这个时候物理内存是随机分配的（解决了安全问题），并且应用程序只是用到的部分加载（内存不够用解决）。如果物理内存满了则数据会被加载到最不活跃的地址去覆盖数据。



`Apple`在物理内存中分配了一块空间（需要申请），不在特殊情况不会被覆盖。这样就实现了保活。比如音乐播放等。

那么加了页表需要查找物理内存会不会影响效率呢？

页表查找物理内存是通过`CPU`上的硬件`MMU`（地址翻译）完成的，并且`CPU`上有高速缓存对查找结果进行缓存。真正影响效率的地方是缺页中断(`pagefault`)，不过这个用户也感知不到。

> 这也就是二进制重排的原理，减少缺页中断。

# 二、ASLR

`ASLR`（`Address space layout randomization`）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。

目前大部分主流的操作系统已经实现了`ASLR`。

- Linux
   `Linux`已在内核版本`2.6.12`中添加`ASLR`。
- Windows
   `Windows Server 2008`，`Windows 7`，`Windows Vista`，`Windows Server 2008 R2`默认情况下启用`ASLR`，但它仅适用于动态链接库和可执行文件。
- Mac OS X
   `Apple`在`Mac OS X Leopard10.5`（2007年10月发行）中某些库导入了随机地址偏移，但其实现并没有提供`ASLR`所定义的完整保护能力。而`Mac OS X Lion10.7`则对所有的应用程序均提供了`ASLR`支持。`Apple`宣称为应用程序改善了这项技术的支持，能让`32`及`64`位的应用程序避开更多此类攻击。从`OS X Mountain Lion10.8`开始，核心及核心扩充（`kext`）与`zones`在系统启动时也会随机配置。
- iOS（iPhone, iPod touch, iPad）
   `Apple`在`iOS4.3`内导入了`ASLR`。
- Android
   `Android 4.0`提供地址空间配置随机加载（`ASLR`），以帮助保护系统和第三方应用程序免受由于内存管理问题的攻击，在`Android 4.1`中加入地址无关代码（`position-independent code`）的支持。

以前应用程序直接加载到物理内存中每次地址是随机的。虚拟内存每次地址都是从`0`开始的。那么虚拟内存就固定了，直接注入恶意程序就能直接访问了。这个时候就出现了`ASLR`。模拟了物理内存每次随机分配。



![img](https:////upload-images.jianshu.io/upload_images/25092736-31e3d410e43b1672.png)

image.png


 在上图中
 文件偏移地址`file offset`：`0x1a70`。
 虚拟内存地址`VM Address`：`0x100001a70`。
 运行虚拟内存地址：`ASLR` + `VM Address`。



# 总结

- 虚拟内存
  - 所有程序的内存访问都是通过虚拟地址访问的。
  - 每个应用程序有一张页表，虚拟地址和物理地址的映射表。
  - 数据加载以页为单位加载。
- ASLR
  - 一种保护技术，在每次加载应用的时候系统给一个随机的偏移值。所以需要`rebase`。
  - 定位方法地址，下内存断点
    - 1、LLDB：image list 找到MachO首地址。
    - 2、找到方法在文件中的虚拟地址、文件中的偏移地址。
    - 3、获取到方法的虚拟地址
      - 3.1、MachO首地址 + 文件中的偏移地址
      - 3.2、MachO中的虚拟地址 + ASLR
        来源：简书
        著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。